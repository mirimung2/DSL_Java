## 자바 데이터 타입, 변수 그리고 배열

### 목표
자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.   


### 학습할 것
* 프리미티브 타입 종류와 값의 범위 그리고 기본 값   
  > 프리미티브 타입(Primitive type)은 기본형으로 논리형, 문자형, 정수형, 실수형으로 4종류로 구분된다.   
  > 자료형으로는 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)로 총 8개의 타입이 있다.   
  > 자바는 C언어와 달리 참조형 변수간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은 모두 기본형 변수이다.   
  >    
  > - **논리형** : true와 false 중 하나를 값으로 가지며, 조건식과 논리적 계산에 사용된다.   
  >    
  > - **문자형** : 문자를 저장하는 데 사용되며, 변수 당 하나의 문자만 저장할 수 있다.   
  >    
  > - **정수형** : 정수 값을 저장하는 데 사용된다. 주로 사용되는 것은 int와 long이며, byte는 이진데이터를 다루는데 주로 사용되고, short는 C언어와의 호환을 위해 추가되었다.   
  > ![image](https://user-images.githubusercontent.com/91665030/136687403-b5a180cf-0831-44c3-805b-cf1cb7a46899.png)   
  > 첫번째 비트는 부호 표현을 의미한다. (0 : 양수, 1 : 음수)   
  > n은 타입의 크기를 의미하며 단위는 bit이다.   
  > 부호를 표현하는 첫번째 비트를 제외한 (n-1) 개의 비트로 숫자를 표현한다.   
  > 정수의 표현 범위는 2^(n-1) ~ 2^(n-1)-1 이다.   
  > (양의 정수는 0을 포함하므로 최대값에서 1을 빼야한다.)   
  >    
  > - **실수형** : 실수 값을 저장하는 데 사용되며, float와 double만 존재한다.    
  > ![image](https://user-images.githubusercontent.com/91665030/136687534-e2109115-075e-4372-bded-f2bd7efa6699.png)   
  > 실수형의 값을 저장하는 형식이 부호(S), 지수(E), 가수(M)으로 되어있어 같은 크기라도 정수형보다 저장 가능한 범위가 훨씬 크다.   
  >    
  > **기본형의 종류와 크기**   
  > 기본 자료형 - 정수형 : int 형, 실수형 : double   
  > |종류/크기|**1byte**|**2byte**|**4byte**|**8byte**|
  > |:---:|:---:|:---:|:---:|:---:|
  > |논리형|boolean||||
  > |문자형||char|||
  > |정수형|byte|short|**int**|long|
  > |실수형|||float|**double**|   
  > 
  > **8가지 기본형(프리미티브 타입)과 저장 가능한 값의 범위**   
  > |자료형|저장 가능한 값의 범위|크기(**bit**)|크기(**byte**)|기본값|
  > |:---:|:---:|:---:|:---:|:---:|
  > |boolean|false, true|8|1|false|
  > |char|'\u0000' ~ '\uffff' (0 ~ 65535)|16|2|'\u0000'|
  > |byte|-128 ~ 127|8|1|0|
  > |short|-32,768 ~ 32,767|16|2|0|
  > |int|-2,147,483,648 ~ 2,147,483,647|32|4|0|
  > |long|-9,223,372,036,854,775,828 ~ 9,223,372,036,854,775,807|64|8|0L|
  > |float|	1.4E-45 ~ 3.4E38 (1.4 x 10^-45 ~ 3.4 x 10^38)|32|4|0F|
  > |double|	4.9E-324 ~ 1.8E308 (4.9 x 10^-324 ~ 1.8 x 10^308)|64|8|0|
  >    

* 프리미티브 타입과 레퍼런스 타입
  > - **프리미티브 타입(기본형)**   
  > boolean, char, byte, short, int 등 이미 정해진 8가지 타입을 제공한다.   
  > 기본값이 있기 때문에 null값이 존재하지 않는다.   
  > 크기가 정해져있고 메모리에 실제값을 저장한다.(stack 메모리에 저장된다.)   
  > 컴파일 시점에 담을 수 있는 크기를 벗어나면 컴파일 에러로 에러가 발생한다.   
  >    
  > - **레퍼런스 타입(참조형)**   
  > 기본형의 8가지 타입을 제외한 모든 타입들이 레퍼런스(참조형) 타입이다.   
  > 빈 객체를 의미하는 null값이 존재한다.   
  > 값이 저장되어 있는 곳의 주소값을 저장한다.(Heap 메모리에 저장된다.)   
  > ![image](https://user-images.githubusercontent.com/91665030/136688732-71217745-5fc3-4621-9000-f2215cdb1b35.png)   
  > 문법상으로 에러가 없지만 실행했을 때 런타임 에러가 발생하여 에러가 날 수 있다.   

* 리터럴
  > 리터럴(literal)이란, 값(데이터) 그 자체를 의미한다.   
  > ![image](https://user-images.githubusercontent.com/91665030/136688872-1ab663b0-a8a2-49e7-b17f-25bd892beef1.png)   
  > 변수에 타입이 있듯이, 리터럴도 타입이 있다.   
  > |종류|리터럴|접미사|
  > |:---:|:---:|:---:|
  > |논리형|false, true|없음|
  > |정수형|123, 0b0101, 077, 0xFF, 100L|'l' or 'L'(long 타입의 리터럴)|
  > |실수형|3.14, 3.0e8, 1.4f|'f' or 'F'(float 타입의 리터럴), 'd' or 'D'(double 타입의 리터럴)|
  > |문자형|'A', '1', '\n'|없음|
  > |문자열형|"ABC", "123", "A", "true"|없음|
  > |기타 리터럴|null, _ |없음|
  >    
  > 정수형과 실수형에는 여러 타입(byte, short, int, long, float, double)이 존재하므로 리터럴에 접미사를 붙여서 구분한다.   
  >    
  > **정수형**의 경우 long 타입의 리터럴에 접미사 'l' 또는 'L'을 붙이며, 접미사가 없다면 int 타입이 된다.   
  > (short나 byte의 리터럴이 별도로 존재하지 않아 int타입의 리터럴을 사용한다. -> 접미사 없음)   
  >    
  > **실수형**의 경우 float 타입의 리터럴에 접미사 'f' 또는 'F'를 붙이며, double 타입의 리터럴에 접미사 'd' 또는 'D'를 붙인다.   
  > 실수형의 기본타입이 double이므로 double 타입의 접미사는 생략 가능하다.  
  >    
  > 10진수 이외의 2, 8, 16진수로 표현된 리터럴을 변수에 저장할 수 있다.   
  > - 2진수 : 0b, 0B   
  > - 8진수 : 0o, 0O   
  > - 16진수 : 0x, 0X   
  >    
  > 제어문자 : 인쇄할 수 없거나 키보드로 표현할 수 없는 특별한 문자, 역슬래시(\)와 한개의 문자를 결합하여 작성
  > - \n : 줄바꿈   
  > - \t : 탭   
  > - \r : 캐리지리턴, 스크린 커서의 위치를 현재 줄의 처음으로 옮긴 후 다음에 오는 문자를 덮어 씌움.   
  > - \\ : 역슬래시(\) 문자를 출력   
  > - \" : 큰 따옴표(")를 출력   
  > - \' : 작은 따옴표(')를 출력   
  > - \b : 백스페이스   
  > - \u : 유니코드 문자   
  > - \f : form feed, 프린트 출력시 현재 페이지를 마치고 다음 페이지로 넘기기 위해 사용   

* 변수 선언 및 초기화하는 방법
  > **변수 선언**은 변수를 사용하기 위해 메모리에 변수 타입에 알맞은 크기의 저장공간이 확보되어 값을 저장할 준비를 하는 것이다.   
  > ```java
  > int a;
  > ```
  > int 타입의 값을 저장할 수 있는 공간을 확보(int 타입은 4byte), 그 공간을 지칭할 이름은 a이다.   
  >    
  > **변수 초기화**는 저장공간에 우너하는 값을 저장하는 것이다.   
  > 변수를 선언하면 해당 공간에는 쓰레기값이 들어있으며, 컴파일 시, 컴파일 에러코드를 보이게 된다.   
  > 따라서 변수는 선언 후에 초기화를 해야한다.   
  > ```java
  > a = 100;
  > ```
  > a라는 변수에 100이라는 값을 넣어줌으로써 초기화한다.   
  >    
  > **변수 선언과 초기화**는 한 번에 동시에 하는 것도 가능하다.   
  > ```java
  > int a = 100;
  > ```
  >    
  > 자바에서 멤버변수는 초기화하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지므로 초기화하지 않고 사용해도 된다.   
  > 하지만 지역변수는 사용 전 반드시 초기화를 해야 에러가 발생하지 않는다.   
  > 멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택적이지만, **지역변수의 초기화는 필수적**이다.   
  > ```java
  > int a;
  >    
  > int c = a; // 에러 X
  >    
  > public void method1() {
  >   int b;
  >   int c = b; // 에러 O
  > }
  > ```

* 변수의 스코프와 라이프타임
  > **변수의 스코프**는 변수에 대한 접근과 존재할 수 있는 영역을 뜻한다.   
  > 자바에서 스코프에 따른 변수의 종류는 클래스변수(static 변수), 인스턴스 변수, 지역변수 3가지로 구분된다.   
  > |변수의 종류|선언 위치|초기화 시점|변수의 스코프|라이프타임|
  > |:---:|:---:|:---:|:---:|:---:|
  > |클래스 변수|클래스 영역|클래스가 메모리에 처음 로딩될 때|클래스 전역|프로그램 종료시까지|
  > |인스턴스 변수|클래스 영역|인스턴스가 생성될 때|각각의 인스턴스|객체가 메모리에 존재하는 동안|
  > |지역 변수|메소드 영역|변수 선언문이 수행됐을 때|메소드 안|메소드 수행 완료시까지|
  >    
  > **라이프타임**은 전역 변수와 지역 변수가 다르다.   
  > 전역 변수는 클래스 내의 모든 영역에서 사용 가능한 변수로 클래스 변수와 인스턴스 변수로 나뉜다.   
  > 클래스 변수는 정적 변수라고 부르며, 프로그램이 실행될 때 클래스와 함께 메모리에 로드되는 변수로 프로그램 종료시 삭제된다.   
  > 인스턴스 변수는 객체를 생성함에 따라 각각의 인스턴스마다 변수의 복사본을 가질 수 있는 변수이며, 객체가 소멸되기 전까지 존재한다.   
  > 하지만 객체를 참조하는 변수가 없을 경우 JVM의 Garbage Collector가 제거하게 된다.    
  > 지역변수는 메소드, 반복문, 생성자 등에서 선언된 변수로 해당 영역내에서 사용이 가능하다.   
  > 하지만 메소드가 모두 수행되면 소멸되어 사용할 수 없게 된다.   

* 타입 변환, 캐스팅 그리고 타입 프로모션
  > 서로 다른 타입간의 변수와 리터럴 연산을 수행하기 위해 타입을 일치시키거나 변환하는 것을 형변환, **타입변환**이라고 한다.   
  > 프리미티브 타입에서 boolean을 제외한 나머지 타입들이 서로 형변환 가능하다.   
  > 프리미티브 타입과 레퍼런스 타입은 서로 형변환할 수 없다.   
  > 프리미티브 타입은 프리미티브 타입, 레퍼런스 타입은 레퍼런스 타입으로만 형변환 가능하다.   
  > 형변환 방법 : 타입을 변환하고자 하는 변수나 리터럴 앞에 변환할 타입을 괄호와 함께 붙이면 된다.   
  > ```java
  > int a = (int)5.23; // double형 값을 int형으로 변환하여 a에는 5가 저장된다.
  > ```
  >    
  > 타입 변환의 종류로는 큰 메모리의 타입을 작은 타입으로 변환하는 **캐스팅**(강제 형변환)과 작은 메모리 타입에서 큰 타입으로 변환하는 **타입 프로모션**(자동 형변환)이 있다.   
  > **캐스팅**은 강제 형변환, 명시적 형변환이라고도 하며 큰 메모리의 타입을 작은 타입으로 변환하고 이에 따라 값 손실이 발생할 수 있다.   
  >    
  > **타입 프로모션**은 자동 형변환으로 '기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다'는 규칙이 있다.   
  > ![image](https://user-images.githubusercontent.com/91665030/136700839-089c894d-dd92-407e-884d-8ec4c3102d57.png)   
  > 그림과 같이 화살표 방향으로 형변환을 하면 자동 형변환이 가능하다.   
  > (char와 short의 경우, char의 범위는 (0 ~ 65535)이고 short의 범위는 (-32768 ~ 32767)로 서로 범위가 달르기 때문에 어느 쪽으로 형변환을 하더라도 값에 손실이 발생할 수 있다. 따라서 자동 형변환을 수행할 수 없으므로 반드시 형변환할 타입을 명시해야 한다.)      

* 1차 및 2차 배열 선언하기
  > 배열은 **같은 타입의 여러 변수**를 하나의 묶음으로 다루는 것이다.   
  > ![image](https://user-images.githubusercontent.com/91665030/136701072-5e72f877-4f78-4d0f-b63c-97b56713fb88.png)   
  > 1차 배열의 선언은 원하는 타입의 변수를 선언하고 변수 또는 타입의 뒤에 배열을 의미하는 대괄호([])를 붙이변 된다.   
  > ```java
  > int[] a;
  > int a[];
  > ```
  > 다음과 같이 배열을 생성하면 초기화하지 않았으므로 null값이 들어가있다.   
  > 배열을 초기화하기 위해선 연산자 'new'와 함께 배열의 타입과 길이를 지정하면 된다.   
  > ```
  > 타입[] 변수이름;
  > 변수이름 = new 타입[길이];
  > ```
  > 1차원 배열을 초기화하는 방법은 다음과 같다.   
  > ```java
  > int[] a;
  > a = new int[3];
  > ```
  >    
  > ```java
  > int[] arr1 = {1, 2, 3};
  > int[] arr2 = new int[3];
  > ```
  >    
  > 2차원 배열을 선언하고 초기화하는 방법은 대괄호를 하나 더 추가하면 된다.   
  > ```java
  > int[][] arr = new int[3][3];
  > int arr[][] = new int[3][3];
  > 
  > int[][] arr3 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
  > ```

* 타입 추론, var
  > **타입 추론**이란 타입이 정해지지 않은 변수의 타입을 컴파일러가 유추하는 기능이다.   
  > 자바에서는 일반 변수에 대한 타입 추론을 지원하지 않기 때문에 자바에서의 타입 추론은 제네릭과 람다에 대한 타입 추론을 말한다.   
  > Java 10부터 추가된 특징 중 하나인 Local Variable Type Inference는 로컬 변수 선언을 var를 이용하여 기존의 엄격한 타입 선언방식에서 컴파일러에게 타입추론 책임을 위임할 수 있게 되었다.   
  > ```java
  > var list = new ArrayList<String>(); // infers ArrayList<String>
  > var stream = list.stream(); //infers Stream<String>
  > ```
  >    
  > Local Variable Type Inference 사용 조건
  > - 초기화된 로컬 변수 선언시
  > - 반복문에서 지역변수 선언시(enhanced for loop 포함)
  >    
  > var 활용
  > 1. 지역변수 선언
  > ```java
  > var numbers = Arrays.asList(1, 2, 3, 4, 5);
  > for (var i = 0; i < numbers.size(); i++) {
  >     System.out.printIn("numbers = " + numbers.get(i));
  > }
  > ```
  >    
  > 2. forEach
  > ```java
  > var numbers = Arrays.asList(1, 2, 3, 4, 5);
  > for (var number : numbers) {
  >     System.out.printIn(number);
  > }
  > ```
  > => 기존에는 Object 타입으로 받아서 형변환을 하거나 IDE가 아닌 개발자가 직접 타입추론해 명시적 타입선언을 해줬는데 var를 사용하여 훨씬 편하게 타입선언이 가능해졌다.   
  >    
  > 3. Lambda(Java 11)
  > ```java
  > IntBinaryOperator plus10 = (@NonNull var one, @NonNull var two) -> one + two + 10;
  > ```
  > => Java 11부터는 람다 인자에도 var 사용이 가능해졌는데, 이를 통해 파라미터 어노테이션 사용까지 가능해졌다.   

#### 참조
https://parkadd.tistory.com/38   
https://tychejin.tistory.com/230   
https://juntcom.tistory.com/111
